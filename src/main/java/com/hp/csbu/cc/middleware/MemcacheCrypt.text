package com.hp.csbu.cc.middleware;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.SimpleTimeZone;
import java.util.concurrent.TimeoutException;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import net.rubyeye.xmemcached.MemcachedClient;
import net.rubyeye.xmemcached.XMemcachedClientBuilder;
import net.rubyeye.xmemcached.exception.MemcachedException;
import net.rubyeye.xmemcached.utils.AddrUtil;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

//import com.hp.csbu.cc.security.cs.thrift.service.AuthResponseV2;
//import com.hp.csbu.cc.security.cs.thrift.service.AuthResponseV3;

/**
 * An internal class to allow encryption and decryption of validated tokens
 * stored in memcache.
 * 
 * @author liemmn
 * 
 */
public class MemcacheCrypt {
	// GMT date format for expiration time stamp in token
	static SimpleDateFormat expiryFormat;
	static {
		expiryFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
		Calendar cal = Calendar.getInstance(new SimpleTimeZone(0, "GMT"));
		expiryFormat.setCalendar(cal);
	}

	// character set to use for converting between chars and bytes
	private static final String CHARSET_NAME = "UTF-8";

	// message digest algorithm
	private static final String DIGEST_ALGORITHM = "SHA-256";

	// key algorithm
	private static final String KEY_ALGORITHM = "AES";

	// cipher algorithm
	private static final String CIPHER_ALGORITHM = KEY_ALGORITHM
			+ "/CBC/PKCS5Padding";

	// Thee password
	private static final String PASSWORD = "G0n30ffTehC11ff!";

	// Wrapped memcache client instance
	//private MemcachedClient client;
	private TokenCache client;

	// Cache value to be encrypted or not
	private boolean isEncrypted;

	// Thee faithful logger
	private static final Logger logger = LoggerFactory
			.getLogger(MemcacheCrypt.class);

	/**
	 * Construct a memcache client instance.
	 * 
	 * @param cacheHosts
	 *            List of memcache servers
	 * @param isEncrypted
	 *            Uses encryption or not
	 * @throws IOException
	 */
	public MemcacheCrypt(String cacheHosts, boolean isEncrypted)
			throws IOException {
		XMemcachedClientBuilder builder = new XMemcachedClientBuilder(
				AddrUtil.getAddresses(cacheHosts));
		this.client = builder.build();
		this.isEncrypted = isEncrypted;
	}

	/**
	 * Shutdown this client instance.
	 * 
	 * @throws IOException
	 */
	public void shutdown() throws IOException {
		client.shutdown();
	}

	/**
	 * Store given token into memcache.
	 * 
	 * @param token
	 *            Token
	 * @param auth
	 *            Token info
	 * @throws TimeoutException
	 * @throws InterruptedException
	 * @throws MemcachedException
	 */
	public void putToken(String token, Object auth) throws TimeoutException,
			InterruptedException, MemcachedException {
		String expires = null;
	/*	if (auth instanceof AuthResponseV2) {
			expires = ((AuthResponseV2) auth).getTokenInfo().getExpires();
		} else {
			expires = ((AuthResponseV3) auth).getToken().getExpires_at();
		}   */
		if (isEncrypted) {
			auth = encrypt(token, PASSWORD, auth);
		}
		client.set("tokens/" + token, expireFromNow(expires), auth);
	}

	/**
	 * Get a token, or null if no token found in cache.
	 * 
	 * @param token
	 *            Token
	 * @param timeout
	 *            Timeout waiting to get token
	 * @return Token info
	 * @throws TimeoutException
	 * @throws InterruptedException
	 * @throws MemcachedException
	 */
	public Object getToken(String token, long timeout) throws TimeoutException,
			InterruptedException, MemcachedException {
		Object o = client.get("tokens/" + token, timeout);
		/*if (o instanceof AuthResponseV2) {
			return (AuthResponseV2) o;
		} else if (o instanceof AuthResponseV3) {
			return (AuthResponseV3) o;
		} else if (o instanceof byte[]) {
			return decrypt(token, PASSWORD, (byte[]) o);
		}
		                                  */
    if (o instanceof byte[]) {
      return decrypt(token, PASSWORD, (byte[]) o);
    }
		return null;
	}

	// Test method... Don't use!
	void setEncrypted(boolean isEncrypted) {
		this.isEncrypted = isEncrypted;
	}

	// Expiration from now in seconds
	private int expireFromNow(String expires) {
		Date tokenDate = null;
		try {
			tokenDate = expiryFormat.parse(expires);
		} catch (ParseException e) {
			logger.error("Error parsing token expiration: " + expires);
		}
		Date current = new Date();
		return (int) ((tokenDate.getTime() - current.getTime()) / 1000);
	}

	/**
	 * Encrypts the given token information
	 * 
	 * @param token
	 *            Token
	 * @param password
	 *            Password used for encryption/decryption
	 * @param auth
	 *            Token info to encrypt
	 * @return Encrypted token info
	 */
	static byte[] encrypt(final String token, final String password,
			final Object tokenData) {
		byte[] encryptedAuth = null;
		ByteArrayOutputStream baos = null;

		try {
			// Compute key and iv from token and password
			Secret secret = genSecret(token, password);

			// Serialize the token info
			baos = new ByteArrayOutputStream();
			ObjectOutputStream os = new ObjectOutputStream(baos);
		/*	if (tokenData instanceof AuthResponseV2) {
				os.writeObject((AuthResponseV2) tokenData);
			} else {
				os.writeObject((AuthResponseV3) tokenData);
			}*/

			byte[] data = baos.toByteArray();

			// Performs 128-AES encryption
			Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);
			cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(secret.key,
					KEY_ALGORITHM), new IvParameterSpec(secret.iv));
			encryptedAuth = cipher.doFinal(data);
		} catch (Exception e) {
			throw new EncryptionException("Failed to encrypt " + token, e);
		} finally {
			if (baos != null)
				try {
					baos.close();
				} catch (IOException e) {
				}
		}
		return encryptedAuth;
	}

	/**
	 * Decrypts the given token info data.
	 * 
	 * @param token
	 *            Token
	 * @param password
	 *            Password used for encryption/decryption.
	 * @param data
	 *            Token info data
	 * @return Token info
	 */
	static Object decrypt(final String token, final String password,
			final byte[] data) {
		ByteArrayInputStream bais = null;
		Object auth = null;

		try {
			// Compute key and iv from token and password
			Secret secret = genSecret(token, password);

			// Performs 128-AES decryption
			Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);
			cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(secret.key,
					KEY_ALGORITHM), new IvParameterSpec(secret.iv));
			byte[] decryptedAuth = cipher.doFinal(data);

			// Deserialize the token info
			bais = new ByteArrayInputStream(decryptedAuth);
			ObjectInputStream ois = new ObjectInputStream(bais);
			auth = ois.readObject();
			bais.close();
		} catch (Exception e) {
			throw new DecryptionException("Failed to decrypt " + token, e);
		} finally {
			if (bais != null)
				try {
					bais.close();
				} catch (IOException e) {
				}
		}
		return auth;
	}

	// Compute key and iv from token and password
	private static Secret genSecret(final String token, final String password)
			throws UnsupportedEncodingException, NoSuchAlgorithmException {
		MessageDigest md = MessageDigest.getInstance(DIGEST_ALGORITHM);
		byte[] seed = (token + password).getBytes(CHARSET_NAME);
		byte[] pw = md.digest(seed);
		Secret secret = new Secret();
		System.arraycopy(pw, 0, secret.key, 0, 16);
		System.arraycopy(pw, 16, secret.iv, 0, 16);
		Arrays.fill(pw, (byte) 0x00);
		return secret;
	}

	// Data object to hold the key and iv for encryption/decryption
	private static final class Secret {
		byte[] key = new byte[16];
		byte[] iv = new byte[16];
	}
}
